// Gradle plugins
buildscript {
    repositories {
        maven {
            url = 'https://dl.bintray.com/lanternpowered/maven/'
        }
    }
    dependencies {
        classpath 'org.lanternpowered:lanterngradle:1.0.0'
    }
}

plugins {
    id 'com.github.hierynomus.license' version '0.14.0'
    id 'com.github.johnrengelman.shadow' version '1.2.4'
    id 'org.spongepowered.plugin' version '0.8.1'
}

apply from: rootProject.file('gradle/lantern.gradle')

// Apply plugin
apply plugin: 'org.lanternpowered.gradle'
apply plugin: 'org.lanternpowered.run-configs'
apply plugin: 'maven'

// Basic project information
archivesBaseName = 'lanternserver'
version = '1.0.0-SNAPSHOT'

sourceSets {
    java6 {
        compileClasspath += main.compileClasspath + main.output
        runtimeClasspath += main.runtimeClasspath + main.output
    }
}

compileJava6Java {
    sourceCompatibility = '1.6'
    targetCompatibility = '1.6'
}

idea.module {
    // The java6 sourceset
    sourceDirs += file('src/java6/java')
}

// Disable some tasks to make the building go faster
api.tasks.javadoc.enabled = false
api.tasks.javadocJar.enabled = false
api.tasks.checkstyleMain.enabled = false
api.tasks.checkstyleTest.enabled = false
// Disable this task to avoid that we turn the dependency
// dirty when we call this on our project
api.tasks.wrapper.enabled = false

configurations {
    // A configuration that will be excluded
    // in the generated pom file
    compileExcluded
    compile.extendsFrom compileExcluded
}

ext.testDataPacks = project(':test-data-packs')
ext.testPlugins = project(':test-plugins')
evaluationDependsOn testPlugins.path

// Project dependencies
dependencies {
    // Add the test plugins to the class path
    compileExcluded testPlugins
    // Add the test data packs to the class path
    compileExcluded testDataPacks
    // Add the sponge api
    compileExcluded api

    // Launch Options
    compile 'net.sf.jopt-simple:jopt-simple:5.0.3'

    // Useful libraries
    compile 'org.apache.commons:commons-lang3:3.5'
    compile 'com.google.guava:guava:21.0'

    // Injection
    compile 'com.google.inject:guice:4.1.0'

    // Json library
    compile 'com.google.code.gson:gson:2.8.0'

    // Network
    compile 'io.netty:netty-all:4.1.12.Final'

    // Logging
    compile 'org.apache.logging.log4j:log4j-slf4j-impl:2.8.1'
    compile 'org.apache.logging.log4j:log4j-core:2.8.1'
    compile 'org.apache.logging.log4j:log4j-api:2.8.1'
    compile 'org.apache.logging.log4j:log4j-iostreams:2.8.1'

    // Console
    compile 'org.jline:jline-terminal-jna:3.4.0'
    compile 'net.java.dev.jna:jna:4.4.0'
    compile 'net.minecrell:terminalconsoleappender:1.0.0'

    // Fastutil
    compile 'it.unimi.dsi:fastutil:7.1.0'

    // Database connectors
    compile 'com.zaxxer:HikariCP:2.6.3'
    compile 'org.mariadb.jdbc:mariadb-java-client:2.0.2'
    compile 'org.xerial:sqlite-jdbc:3.19.3'
    compile 'com.h2database:h2:1.4.196'

    // Scripting
    compile 'org.codehaus.groovy:groovy-all:2.4.11'

    // Asm
    compile 'org.ow2.asm:asm-all:5.2'

    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-library:1.3'
    testCompile 'org.mockito:mockito-core:2.8.47'
}

runConfigurations {
    theConfig {
        name = 'Lantern Server'
        mainClass = 'org.lanternpowered.launch.LanternLaunch'
        workingDirectory = 'run'
    }
}

// Always print full stack trace if something goes wrong in the unit tests
test.testLogging.exceptionFormat = 'full'

import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import groovy.json.JsonBuilder

processResources {
    // Minimize the json files
    doLast {
        fileTree(dir: outputs.files.asPath, include: 'internal/*.json').each {
            File file -> file.text = JsonOutput.toJson(new JsonSlurper().parse(file))
        }
    }
}

////////////////////////////////////
/// Collect Dependency Artifacts ///
////////////////////////////////////

def ignoredDependencyArtifacts = new HashSet<>()
// Don't include the api again
ignoredDependencyArtifacts.add "$api.group:$api.name"
ignoredDependencyArtifacts.add "$testDataPacks.group:$testDataPacks.name"
ignoredDependencyArtifacts.add "$testPlugins.group:$testPlugins.name"
// We already include 'asm-all'
ignoredDependencyArtifacts.add 'org.ow2.asm:asm'

def dependencyArtifacts = new ArrayList<>()

configurations.compile.resolvedConfiguration.resolvedArtifacts.each { ResolvedArtifact a ->
    def id = a.moduleVersion.id
    def e = "$id.group:$id.name"
    // Check if we want the artifact, check for the java (String) and groovy strings (GString)
    if (!ignoredDependencyArtifacts.contains(e) && !ignoredDependencyArtifacts.contains((String) e)) {
        dependencyArtifacts.add(a)
    }
}

/////////////////////////////////////////////////
/// Generate the jar with all the lantern and ///
///  sponge classes, and all their resources. ///
/////////////////////////////////////////////////

jar {
    exclude 'log4j2.xml'
    rename 'log4j2_prod.xml', 'log4j2.xml'

    // Include the api classes
    from api.sourceSets.main.output
    // Include generated event classes
    from fileTree(api.tasks.genEventImpl.outputs.files.first())

    // Include the java 6 classes
    from sourceSets.java6.output

    /////////////////////////////////////////
    /// Generate a json file with all the ///
    //    dependencies and repositories.  ///
    /////////////////////////////////////////

    def specifiedUrls = new HashSet<>()
    def repositoryEntries = new ArrayList<>()
    // Generate a json file with all the dependencies and repositories
    repositories.each { repo ->
        URL url = repo.url.toURL()
        if (url.protocol == 'file') {
            return
        }
        def s = url.toString()
        if (specifiedUrls.contains(s)) {
            return
        }
        specifiedUrls.add(s)

        def properties = new HashMap<>()
        properties['url'] = s

        repositoryEntries.add(properties)
    }

    def dependencyEntries = new ArrayList<>()
    dependencyArtifacts.each { ResolvedArtifact a ->
        def d = dependencies.create(a.moduleVersion.id.toString())

        // Generate the properties
        def properties = new HashMap<>()
        properties['group'] = d.group
        properties['name'] = d.name
        properties['version'] = d.version

        // Add them to the list
        dependencyEntries.add(properties)
    }

    def data = new HashMap<>()
    data['repositories'] = repositoryEntries
    data['dependencies'] = dependencyEntries

    def librariesFile = new File(buildDir, 'libraries.json')
    librariesFile.text = new JsonBuilder(data).toPrettyString()

    from librariesFile
}

/////////////////////////////////////////
/// Generate a fat jar which includes ///
///     all the dependency jars.      ///
/////////////////////////////////////////

task fatJar(type: Jar, dependsOn: jar) {
    // Include the default jar
    from zipTree(jar.archivePath)

    // Always update the fat jar
    outputs.upToDateWhen { false }

    // Generate the dependencies
    classifier = 'fat'

    dependencyArtifacts.each { ResolvedArtifact a ->
        Dependency d = dependencies.create(a.moduleVersion.id.toString())
        from (a.file, { spec ->
            spec.rename {
                "libraries/${d.group.replace('.', '/')}/$d.name/$d.version/$d.name-${d.version}.jar"
            }
        })
    }
}
// Run fatJar on build
assemble.dependsOn fatJar

/////////////////////////////////////////////
/// Apply manifest file properties to the ///
///        fat and normal jars.           ///
/////////////////////////////////////////////

afterEvaluate {
    [jar, fatJar]*.manifest {
        attributes(
                'Main-Class': 'org.lanternpowered.launch.VersionCheckingMain',
                'Implementation-Name': project.name,
                'Implementation-Version': project.version,
                'Implementation-Vendor': project.url,
                'Specification-Name': api.name,
                'Specification-Version': api.version,
                'Specification-Vendor': api.url
        )
        if (commit) attributes['Git-Commit'] = commit
        if (branch) attributes['Git-Branch'] = branch
    }
}

////////////////////////////////////////////////////
/// Generate a source jar which includes all the ///
//    sources from lantern and the sponge api.   ///
////////////////////////////////////////////////////

sourceJar {
    from sourceSets.java6.allSource

    from api.sourceSets.main.allSource
    from api.sourceSets.ap.allSource
}

artifacts {
    archives jar
    archives sourceJar
}

////////////////////////////////////
/// Gradle Wrapper update tasks. ///
////////////////////////////////////

// Gradle version used for generating the Gradle wrapper
task wrapper(type: Wrapper) {
    gradleVersion = '4.0'
}

// A custom update wrapper task, using a custom task prevents
// intellij from updating the wrapper constantly through
// the wrapper task
task updateWrapper(dependsOn: wrapper)

gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    // Only enable the wrapper task if the updateWrapper task is run
    wrapper.enabled = graph.allTasks.contains(updateWrapper)
}